<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<!DOCTYPE doc
  SYSTEM '../../clonk.dtd'>
<?xml-stylesheet type="text/xsl" href="../../clonk.xsl"?>
<doc>
  <title>#appendto</title>
  <h>#appendto</h>
  <part>
    <text>With #appendto, you can modify an existing object defintion script without changing the original file. For example, a scenario could change flints to cause bigger explosions, without having to duplicate the entire flint in the scenario.</text>
    <h id="Syntax">Declaration</h>
    <code>#appendto [id]</code>
    <text>A script can append itself to one or multiple existing scripts using the <code>#appendto</code> directive. Such script needs to be placed in System.ocg directory. Functions of the same name will overload functions in the target script. The original overloaded functions can still be called using <emlink href="script/fn/inherited.html">inherited</emlink>. #included scripts are not appended with #append, but #appended scripts are included by #include.</text>
    <code>#appendto *</code>
    <text>Appending to <code>*</code> will append this script to all definitions.</text>
    <text>A script can contain multiple #appendto directives. It is always compiled with the original script. This is of interest whenever local variables or functions from the appended script are used.</text>
    <h id="Example">Example</h>
    <code>#appendto WindBag


// This function will be "overwritten" in the original windbag
// You can however call the original function by calling _inherited(...)
// You'll find this quite often in other scenarios. Just take a look at other
// scenarios that contain a System.ocg folder.
func FxIntReloadTimer(object target, proplist effect, int time)
{
	if (fill_amount > MaxIntake)
		return FX_Execute_Kill;
		
	if (GBackSolid(0,0) || GBackLiquid(0,0))
	{
		if (effect.sound)
		{
			Sound("Objects::Windbag::Charge", {loop_count = -1});
			Sound("Objects::Windbag::ChargeStop");
			effect.sound = false;
		}
		return FX_OK;
	}

	var radius = RandomX(12, 24);
	var angle = Random(360);
	var angle_var = RandomX(-25, 25);
	var x = Sin(angle + angle_var, radius);
	var y = Cos(angle + angle_var, radius);
	// Check for a spot of air from which to take the air in.
	if (!GBackSolid(x, y) &amp;&amp; !GBackLiquid(x, y) &amp;&amp; !GBackSolid(0, 0) &amp;&amp; !GBackLiquid(0, 0)) 
	{
		if (!effect.sound)
		{
			Sound("Objects::Windbag::Charge", {loop_count = 1});
			effect.sound = true;
		}
		
		// Particles from the point where the air is sucked in.
		var air = {
			Prototype = Particles_Air(), 
			Size = PV_KeyFrames(0, 0, 0, 250, 3, 1000, 0)
		};
		CreateParticle("Air", x, y, -2 * x / 3, -2 * y / 3, 15, air);
		
		// Increase the fill amount proportional to the number of frames.
		fill_amount += effect.Interval * 5; 
	}
	return FX_OK;
}</code>
  </part>
  <author>Sven2</author><date>2002-04</date>
  <author>matthes</author><date>2004-06</date>
  <author>GÃ¼nther</author><date>2006-01</date>
</doc>
